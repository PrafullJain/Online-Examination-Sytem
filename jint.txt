\tQUESTIONS\t	\tR1\t	\tR2\t	\tR3\t	\tR4\t	\tMARKS\t	\tSNO\t	\tCANSWER\t	\tUANSWER\t	\tEXPLANATION\t
\tWhich class does not override the equals{} & hashCode{} methods,Inheriting them directly from class object?\t	\tjava.lang.String\t	\tjava.lang.Double\t	\tjava.lang.stringBuffer\t	\tjava.lang.Character\t	\t5.0\t	\t1\t	\tjava.lang.stringBuffer\t	\tjava.lang.Double\t	\tBecause StringBuffer is mutable, and its primary use is for constructing strings. If you want to compare content, call StringBuffer#toString() and compare the returned value.It is not generally useful to override hashCode() for mutable objects, since modifying such an object that is used as a key in a HashMap could cause the stored value to be lost.\t
\tWhich interface provide not any duplicate elements capability in natural order?\t	\tjava.util.Map\t	\tjava.util.Set\t	\tjava.util.List\t	\tjava.util.Collection\t	\t5.0\t	\t2\t	\tjava.util.Set\t	\tjava.util.Set\t	\tBecause Set is a collection of distinct objects.When you create a set there can be only unique objects in it by definition. Adding same object twice does not change the set as the element/object is already in the set. This is expected behavior. An example where this behavior is useful is when one wants to find unique elements from a collection of elements (i.e. remove duplicates).\t
\tWhich is true about anonymous inner class?\t	\tIt extend 1 class & implement 1 interface\t	\tIt extend 1 class & implement multiple interfaces\t	\tIt extend 1 class or implement 1 interface\t	\tNone of the above\t	\t5.0\t	\t3\t	\tIt can extend exactly one class or implement exactly one interface.\t	\tIt extend 1 class & implement multiple interfaces\t	\tThere is no explanation for these question.\t
\tWhich one are valid constructor for thread?\t	\tThread(Runnable r,String name)\t	\tThread(int priority)\t	\tThread(Runnable r,int priority)\t	\tNone of the above\t	\t5.0\t	\t4\t	\tThread(Runnable r,String name)\t	\tThread(int priority)\t	\tThere is no explanation for these question.\t
\tWhich two of the following methods are defined in Thread class?\t	\tstart() & run()\t	\twait() & notify()\t	\tnotifyAll() & wait()\t	\tNone of the above\t	\t5.0\t	\t5\t	\tstart() & run()\t	\twait() & notify()\t	\tThere is no explanation for these question.\t
\tWhat condition in which currently executing thread stop?\t	\tWhen the stop() method is called\t	\tWhen an Interrupted exception occurs\t	\tWhen thread creates a new thread\t	\tNone of the above\t	\t5.0\t	\t6\t	\tWhen an Interrupted exception occurs\t	\tWhen an Interrupted exception occurs\t	\tThere is no explanation for these question.\t
\tWhich statement is true?\t	\tnotifyAll() method must be called from synchronized context\t	\twait() method be called to provide lock on any thread\t	\tnotify() method is defined in java.lan.Thread\t	\tnotify() method causes a thread to immediately release its lock\t	\t5.0\t	\t7\t	\tnotifyAll() method must be called from synchronized context\t	\twait() method be called to provide lock on any thread\t	\tTo call wait(), an object must own the lock on the thread because notify() will not cause a thread to release its locks. The thread can only release its locks by exiting the synchronized code.\t
\tWhich one gurantee that a thread will leave a running state?\t	\tyield()\t	\tnotify()\t	\tsleep(100)\t	\tnotifyAll()\t	\t5.0\t	\t8\t	\tsleep(100)\t	\tsleep(100)\t	\tBecause sleep method cause a thread to sleep for specific amount of time in milliseconds and it make the thread in waiting state but it is not valid process to stop the thread.\t
\tWhich statement is true for:public class A{ A{} {} },class B extends A {} ?\t	\tClass B constructor is public\t	\tClass B constructor has no arguments\t	\tClass B constructor includes a call to this()\t	\tNone of these\t	\t5.0\t	\t9\t	\tClass B constructor has no arguments\t	\tNone of these\t	\tThere is no explanation for these question.\t
\tWhich statement is true?\t	\tTry statement must have at least one corresponding catch block\t	\tMultiple cache statements can catch the same class of exception more than once\t	\tIn case of VM shutdown,if try start to execute a correspondng finally will also start to execute\t	\tNone of these\t	\t5.0\t	\t10\t	\tIn case of VM shutdown,if try start to execute a correspondng finally will also start to execute\t	\tMultiple cache statements can catch the same class of exception more than once\t	\tThere is no explanation for these question.\t
